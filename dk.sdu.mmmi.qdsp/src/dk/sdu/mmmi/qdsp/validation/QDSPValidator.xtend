/*
 * generated by Xtext
 */
package dk.sdu.mmmi.qdsp.validation
//import org.eclipse.xtext.validation.Check

import dk.sdu.mmmi.qdsp.generator.MoreMath
import dk.sdu.mmmi.qdsp.qDSP.Address
import dk.sdu.mmmi.qdsp.qDSP.Constant
import dk.sdu.mmmi.qdsp.qDSP.Define
import dk.sdu.mmmi.qdsp.qDSP.Element
import dk.sdu.mmmi.qdsp.qDSP.Model
import dk.sdu.mmmi.qdsp.qDSP.Operation
import dk.sdu.mmmi.qdsp.qDSP.QDSPPackage
import dk.sdu.mmmi.qdsp.qDSP.Variable
import dk.sdu.mmmi.qdsp.qDSP.qInstruction
import org.eclipse.emf.ecore.EStructuralFeature
import dk.sdu.mmmi.qdsp.qDSP.Setting
import dk.sdu.mmmi.qdsp.qDSP.RuntimeProgrammable
import dk.sdu.mmmi.qdsp.qDSP.Settings
import dk.sdu.mmmi.qdsp.qDSP.FuncLoader
import org.eclipse.xtext.validation.Check
import dk.sdu.mmmi.qdsp.qDSP.MyMath
import dk.sdu.mmmi.qdsp.qDSP.MathFunc
import dk.sdu.mmmi.qdsp.qDSP.FuncPare
import dk.sdu.mmmi.qdsp.qDSP.FuncTrunctate16
import dk.sdu.mmmi.qdsp.qDSP.FuncMin
import dk.sdu.mmmi.qdsp.qDSP.FuncMax
import dk.sdu.mmmi.qdsp.qDSP.FuncLoop
import dk.sdu.mmmi.qdsp.qDSP.FuncIf
import dk.sdu.mmmi.qdsp.qDSP.FuncSwitch
import dk.sdu.mmmi.qdsp.qDSP.MyBoolean
import dk.sdu.mmmi.qdsp.qDSP.FuncFor
import dk.sdu.mmmi.qdsp.qDSP.qdInstruction
import dk.sdu.mmmi.qdsp.qDSP.HeapSize
import dk.sdu.mmmi.qdsp.qDSP.ProgramMemorySize

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class QDSPValidator extends AbstractQDSPValidator {
	
	@Check
	def runBootloader (Setting setting){
		var Model model = (setting.eContainer as Settings).eContainer as Model;
		if(setting instanceof RuntimeProgrammable){
			var tmp = setting as RuntimeProgrammable;
			if(tmp.^val && !model.eAllContents.filter(qInstruction).exists[(it as qInstruction).func instanceof FuncLoader]){
				error("If the QDSP is runtime programmable, the function runBootLoader() have to run frequently", setting, QDSPPackage$Literals::RUNTIME_PROGRAMMABLE__VAL);
			}
		}
	}
	
	@Check
	def heapAndProgramLength (Setting setting){
		var Model model = (setting.eContainer as Settings).eContainer as Model;
		var runtimeProgrammabel = model.settings.settings.filter(RuntimeProgrammable).exists[(it as RuntimeProgrammable).^val]
		
		if(setting instanceof HeapSize && !runtimeProgrammabel){
			warning("The HeapSize is ignored when not runtime programmable", setting, QDSPPackage.Literals::SETTING__NAME);
		}
		if(setting instanceof ProgramMemorySize && !runtimeProgrammabel){
			warning("The ProgramMemorySize is ignored when not runtime programmable", setting, QDSPPackage.Literals::SETTING__NAME);
		}
	}
	
//	@Check
//	def runtimeProgrammable(Element element){
//		if(element instanceof qInstruction){
//			var Model model = element.eContainer as Model;
//			var instruction = element as qInstruction;
//			if(instruction.func instanceof FuncLoader){
//				if(model.settings.settings.filter(RuntimeProgrammable).exists[(it as RuntimeProgrammable).^val == "false"]){
//					error("The function runBootLoader() is only allowed if the QDSP is runtime programmable", element, QDSPPackage$Literals::QINSTRUCTION__FUNC);
//				}
//			}
//		}
//	}

	@Check
	def unusedVariable(Element element){
		if(element instanceof qInstruction){ return	}
		if(element instanceof Constant){ return	}
		var Model model = element.eContainer as Model;

		
		var String test_name;
		var boolean assigned
		var boolean used
		var EStructuralFeature feature;
		switch element{
			Variable:{
				test_name = element.name;
				feature = QDSPPackage$Literals::VARIABLE__NAME;
				assigned = element.math != null
			}
			Define:{
				test_name = element.name;
				assigned = element.value.addressRead
				used = !element.value.addressRead
				feature = QDSPPackage$Literals::DEFINE__NAME;
			}
		}
		
		for (Variable it : model.eAllContents.filter(Variable).toIterable) {
			if (it.math != null) {
				used = used || detecteUsage(it.math, element, assigned)
			} 
		}
		
		for (qinst : model.eAllContents.filter(qInstruction).toIterable) {
			var qInstruction it = qinst as qInstruction;
			if (inst!= null) {
				used = used || detecteUsage(it, element, assigned)
				assigned = (inst.res == element) ||  assigned
			} else if (func != null) {
				used = used || detecteUsage(it, element, assigned)
			}
			
		}
		
		if (!assigned && !used) {
			warning("Element is never used", element, feature);
		} else if (!assigned) {
			warning("Element is never assigned a value", element, feature);
		} else if (!used) {
			warning("Element value is never used", element, feature);
		}	
		
	}
	
	private def boolean detecteUsage(qInstruction it, Element element, boolean assigned) {
		if (inst!= null) {
			return detecteUsage(it.inst,element,assigned);
		} else if (func != null) {
			switch func {
				FuncLoop: return detecteUsage(func as FuncLoop, element,assigned)
				FuncIf: return detecteUsage(func as FuncIf, element,assigned)
				FuncSwitch: return detecteUsage(func as FuncSwitch, element,assigned)
			}
		}
		return false
	}
	
	private def boolean detecteUsage(qdInstruction it, Element element, boolean assigned) {
		var boolean used = false;
		if (it.add != null) {
			if (res == element) {
				if (!assigned) {
					warning("Element is used before being assigned a value",it, QDSPPackage.Literals::QD_INSTRUCTION__RES)
				}
			used = true
			}
		}
		
		
		used = used || detecteUsage(it.value, element, assigned);
		return used
	}
	
	private def boolean detecteUsage(MyBoolean it, Element element, boolean assigned) {
		var boolean used = false;
		if (val2 != null) {
			used =  used || detecteUsage(val2,element,assigned)
			used = 	used || detecteUsage(val3,element,assigned)
		}
		return used
	}
	
	private def boolean detecteUsage(FuncIf it, Element element, boolean assigned) {
		var boolean used = false;
		used = detecteUsage(bool,element,assigned)
		
		for(elseif : elseifs) {
			used = used || detecteUsage(elseif.bool,element,assigned)
		}
		
		return used
	}
	
	private def boolean detecteUsage(FuncFor it, Element element, boolean assigned) {
		var boolean used = false;
		used = 	used || detecteUsage(bool,element,assigned)
		//used = 	used || detecteUsage(insts1,element,assigned)
		//used = 	used || detecteUsage(insts2,element,assigned)
		return used
	}
	
	private def boolean detecteUsage(FuncLoop it, Element element, boolean assigned) {
		var boolean used = false;
		used = 	used || detecteUsage(bool,element,assigned)
		
		
		
		return used
	}

	private def boolean detecteUsage(FuncSwitch it, Element element, boolean assigned) {
		var boolean used = false;
		used = detecteUsage(it.val2,element,assigned)
		return used
	}
	
	private def boolean detecteUsage(MathFunc func, Element element, boolean assigned) {
		var boolean found = false;
		
		switch func {
			FuncPare: found = detecteUsage(func.value, element, assigned)
			FuncTrunctate16 : found = detecteUsage(func.value, element, assigned)
			FuncMin :
				{
					found = detecteUsage(func.val1, element, assigned)
					if (func.val2 == element) {
						if (!assigned) {
							warning("Element is used before being assigned a value",func, QDSPPackage.Literals::FUNC_MIN__VAL2)
						}
						found = true
					}
				}
			FuncMax :
				{
					found = detecteUsage(func.val1, element, assigned)
					if (func.val2 == element) {
						if (!assigned) {
							warning("Element is used before being assigned a value",func, QDSPPackage.Literals::FUNC_MAX__VAL2)
						}
						found = true
					}
				}
		}
		
		return found
	}
	
	private def boolean detecteUsage(MyMath it, Element element, boolean assigned) {
		var boolean found = false;
		if (^val != null) {
			if (^val == element) {
				if (!assigned) {
					warning("Element is used before being assigned a value",it, QDSPPackage.Literals::MY_MATH__VAL)
				}
				found = true
			}
		} else if (valf != null) {
			found = found || detecteUsage(valf,element,assigned)
		}
		
		for (it : operations) {
			if (^val != null) {
				if (^val == element) {
					if (!assigned) {
						warning("Element is used before being assigned a value",it, QDSPPackage.Literals::OPERATION__VAL)
					}
					found = true
				}
			} else if (valf != null) {
				found = found || detecteUsage(valf,element,assigned)
			}
		}
		
		return found
	}
	
	@Check
	def dublicatNames(Element element){
		if(element instanceof qInstruction){ return	}
		var Model model = element.eContainer as Model;
		
		
		var String test_name;
		var EStructuralFeature feature;
		switch element{
			Constant:{
				test_name = element.name;
				feature = QDSPPackage$Literals::CONSTANT__NAME;
			}
			Variable:{
				test_name = element.name;
				feature = QDSPPackage$Literals::VARIABLE__NAME;
			}
			Define:{
				test_name = element.name;
				feature = QDSPPackage$Literals::DEFINE__NAME;
			}
		}
		val tester = test_name
		if(	model.elements.filter(Constant).exists[(it as Constant).name == tester && it != element] ||
			model.elements.filter(Variable).exists[(it as Variable).name == tester && it != element] ||
			model.elements.filter(Define).exists[(it as Define).name == tester && it != element]){
				error("Two or more elements with same name", element, feature);
			}
	}
	
	@Check
	def devideByPowerOfTwo(Operation operation) {
		if (operation.operator == "/" && !MoreMath.IsPowerOf2(operation.valn.value)) {
			error(operation.valn.value + " is not a power of 2. Can only divide with power of 2", operation, QDSPPackage$Literals::OPERATION__VALN);
		}
	}
	

   
  	@Check
	def writeAddress(qdInstruction instruction) {
		var Address it;
		if(instruction.res instanceof Define){
			it = (instruction.res as Define).value;
			if(isAddressRead(it)){
				error("Cannot write to a read address", instruction, QDSPPackage.Literals::QD_INSTRUCTION__RES);
			}
		}
		if(instruction.res2 != null){
			it = instruction.res2;
			if(isAddressRead(it)){
				error("Cannot write to a read address", instruction, QDSPPackage.Literals::QD_INSTRUCTION__RES2);
			}
		}
	}
  
  
  	def boolean isAddressRead(Address it){
  		if(chanel == "IO"){
  			return (address/4)%2 == 0
  		} else {
  			return (address/4)%2 == 1
  		}
  		
  	}
  
//public static val INVALID_NAME = 'invalidName'
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}